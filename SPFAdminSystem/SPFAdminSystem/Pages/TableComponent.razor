@inject IJSRuntime js;

<table>
    <tr>
        <button onclick="@((object e)=>Toggles[ToggleArrowIdentifier[DateS]].changeDirection(DateS))">
        <th>Date<icon hidden=@Toggles[ToggleArrowIdentifier[DateS]].hidden class="oi oi-caret-@Toggles[ToggleArrowIdentifier[DateS]].directionEnding"></icon></th>
        </button>
        <button onclick="@((object e)=>Toggles[ToggleArrowIdentifier[UserS]].changeDirection(UserS))">
        <th>User<icon hidden=@Toggles[ToggleArrowIdentifier[UserS]].hidden class="oi oi-caret-@Toggles[ToggleArrowIdentifier[UserS]].directionEnding"></icon></th>
        </button>
        <button onclick="@((object e)=>Toggles[ToggleArrowIdentifier[TypeS]].changeDirection(TypeS))">
        <th>Type<icon hidden=@Toggles[ToggleArrowIdentifier[TypeS]].hidden class="oi oi-caret-@Toggles[ToggleArrowIdentifier[TypeS]].directionEnding"></icon></th>
        </button>
        <button onclick="@((object e)=>Toggles[ToggleArrowIdentifier[ValueS]].changeDirection(ValueS))">
        <th>Value<icon hidden=@Toggles[ToggleArrowIdentifier[ValueS]].hidden class="oi oi-caret-@Toggles[ToggleArrowIdentifier[ValueS]].directionEnding"></icon></th>
        </button>
        <button onclick="@((object e)=>Toggles[ToggleArrowIdentifier[ProductS]].changeDirection(ProductS))">
        <th>Product<icon hidden=@Toggles[ToggleArrowIdentifier[ProductS]].hidden class="oi oi-caret-@Toggles[ToggleArrowIdentifier[ProductS]].directionEnding"></icon></th>
        </button>
    </tr>
    @foreach(var action in actions){
    <tr>
        <td>
            @action.Date
        </td>
        <td>@action.User.FullName</td>
        <td>@action.ActionType</td>
        <td>@action.Value</td>
        <td>@action.Product.InHouseTitle</td>
    </tr>
    }
</table>

@code{
    [Parameter]
    public List<UserAction> actions{ get; set; }

    public string DateS = "date";
    public string UserS="user";
    public string TypeS = "type";
    public string ValueS="value";
    public string ProductS = "product";

    static public List<ToggleArrow> Toggles = new List<ToggleArrow> { 
        new ToggleArrow(), new ToggleArrow(), new ToggleArrow(), new ToggleArrow(), new ToggleArrow() };

    public Dictionary<string, int> ToggleArrowIdentifier = new Dictionary<string, int>(){
        {"date",0},
        {"user",1},
        {"type",2},
        {"value",3},
        {"product",4}
    };

    protected override async Task OnInitializedAsync(){
        Toggles[ToggleArrowIdentifier[DateS]].hidden = false;
    }

    public class ToggleArrow
    {
        public string directionEnding = "bottom";
        public bool hidden = true;
        bool sortingDirection = true;
        public void changeDirection(string sortingAttribute){
            directionEnding = directionEnding == "bottom" ? "top" : "bottom";
            sortingDirection = !sortingDirection;
            if(hidden){ // This toggle is hidden, hence another toggle must be visible, so we hide all
                foreach(var toggle in Toggles){
                    toggle.hidden = true;
                }
            }
            hidden = false;
            //actions=SortActionsBy(actions,sortingAttribute,sortingDirection);
        }
    }

    public static List<UserAction> SortActionsBy(List<UserAction> actions,string sortBy,bool desc)
    {
        switch (sortBy)
        {
            case "date":
                if (desc)
                    actions = actions.OrderByDescending(a => a.Date).ToList();
                else
                    actions = actions.OrderBy(a => a.Date).ToList();
                break;
            case "user":
                if (desc)
                    actions = actions.OrderByDescending(a => a.User).ToList();
                else
                    actions = actions.OrderBy(a => a.User).ToList();
                break;
            case "type":
                if (desc)
                    actions = actions.OrderByDescending(a => a.ActionType).ToList();
                else
                    actions = actions.OrderBy(a => a.ActionType).ToList();
                break;
            case "value":
                if (desc)
                    actions = actions.OrderByDescending(a => a.Value).ToList();
                else
                    actions = actions.OrderBy(a => a.Value).ToList();
                break;
            case "product":
                if (desc)
                    actions = actions.OrderByDescending(a => a.Product).ToList();
                else
                    actions = actions.OrderBy(a => a.Product).ToList();
                break;
        }
        return actions;
    }
}